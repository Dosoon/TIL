# TCP/IP 프로토콜, 통신 모델, 소켓의 개념

## 1. TCP/IP 프로토콜

통신 개체는 크게 **호스트**와 **라우터**로 나눌 수 있다.
* **호스트** : 응용을 수행하는 주체
* **라우터** : 호스트 간에 데이터를 교환할 수 있도록 경로를 안내하는 장치
* **통신 프로토콜** : 통신하기 위해 만들어진 절차와 방법
	* ex. TCP/IP, UDP/IP, FTP, HTTP, ...

응용은 **운영체제가 제공하는** TCP/IP 프로토콜을 사용해 통신한다. TCP/IP 프로토콜에서 사용되는 계층 구조는 다음과 같다.
1. 네트워크 접근 계층 (L2) - **Ethernet**
: **실제로 데이터를 송수신**하는 계층
물리 주소(**MAC 어드레스**)를 사용해 통신한다.
> 물리 주소는 윈도우에서 ipconfig 명령을 통해 확인 가능하다.
2. 인터넷 계층 (L3) - **IP**
: 논리 주소(**IP 주소**)를 사용해 데이터를 목적지 호스트로 전달한다.
3. 전송 계층 (L4) - **Port**
: **포트 번호**를 사용해 호스트의 **특정 프로세스**로 데이터를 전달한다.
전송 계층의 프로토콜은 TCP와 UDP가 있다.

| TCP | UDP |
| --- | --- |
| **연결형** | **비연결형** |
| 신뢰성 있는 데이터 전송<br>**재전송 O** | 신뢰성 없는 데이터 전송<br>**재전송 X** |
| **일대일** 통신 | **일대일, 일대다** 통신 |
| 데이터 경계를 구분하지 않는<br>**바이트 스트림** 서비스 | 데이터 경계를 구분하는 <br>**데이터그램** 서비스 |

4. 응용 계층 (L7) - HTTP, FTP, ...

* **패킷** : 헤더, 데이터, 트레일러로 구성된 통신 단위

||||||
|-|-|-|-|-|
|이더넷 헤더(MAC)|IP 헤더(IP)|TCP 헤더(Port)|데이터|이더넷 트레일러|
||||||
> **각 계층은 동일한 위치의 상대편 계층과 통신하는 것으로 간주**할 수 있으며, 응용 프로그래머는 다른 계층의 헤더와 관계없이 주고받는 데이터에만 집중하여 개발할 수 있다.

* **IPv4** : 32비트로 이루어진 주소 체계 (ex. 127.0.0.1)
* **IPv6** : 128비트로 이루어진 주소 체계 (ex. 0:0:0:0:0:0:0:1)
> **루프백 주소** : 시스템 자신을 나타내는 의미로 내부에서 사용되는 주소
	> ex. 127.0.0.1, 0:0:0:0:0:0:0:1, ::1
* 영역별 포트 번호
	* **0~1023** : **주로 표준에서 사용**하는, 알려진 포트
	* **1024~49151** : 일반적으로 서버를 작성할 때 사용하는 포트
	* 49152~65535 : 동적 / 사설 포트
* **도메인 주소** : IP주소를 기억하고 사용하기 불편해 만들어진, IP주소로 치환되는 서버의 다른 이름

## 2. 통신 모델
* **클라이언트-서버 모델** : 네트워크에서 일반적으로 작성되는 모델
	* IP와 포트를 사용해, 서버에 클라이언트가 접속하는 형태
	* **클라이언트가 보내는 패킷에 클라이언트의 정보가 들어있기 때문에**, 서버는 클라이언트의 주소를 미리 알 필요가 없다.
	* 또한, 서버는 해당 정보를 이용해 클라이언트에 언제든 데이터를 보낼 수도 있다.

## 3. 소켓
* **소켓의 개념**
	* 데이터 타입 측면에서 : **파일 디스크럽터**, **핸들**과 유사한 개념
	만들고 나면 응용은 소켓을 사용해 통신을 수행한다.
	* 응용 관점에서 : **통신 종단점**
	클라이언트는 send()를 사용해 서버 소켓에 데이터를 보내고, 서버는 recv()를 사용해 클라이언트로부터 데이터를 받는다.
	* TCP/IP 프로토콜 관점에서 : **네트워크 프로그래밍 인터페이스**
	일반적으로 **응용과 전송 계층 사이**에 위치한다고 간주된다.

* **윈도우 소켓**의 특징
	1. DLL을 통해 기능이 제공되므로 **DLL 초기화와 종료를 위한 함수 필요**
	2. 윈도우는 대개 GUI 기반이므로 **GUI를 위한 확장 함수가 존재**
	3. 윈도우가 멀티스레드를 OS 차원에서 지원하므로 **멀티 스레드 환경에서 동작하는 구조와 함수가 필요**
	4. **유닉스 소켓과 호환성이 높아 기존 코드의 이식이 용이함**
	5. **저수준 프로그래밍 인터페이스**이므로, 세부 제어를 통해 고성능 네트워크 프로그램을 개발할 수 있음